[{"/Users/tangxiaobao/Documents/code/study/element-finder/src/common/index.js":"1","/Users/tangxiaobao/Documents/code/study/element-finder/src/content/index.js":"2","/Users/tangxiaobao/Documents/code/study/element-finder/src/background/index.js":"3","/Users/tangxiaobao/Documents/code/study/element-finder/src/pages/popup/index.js":"4","/Users/tangxiaobao/Documents/code/study/element-finder/src/pages/panel/index.js":"5","/Users/tangxiaobao/Documents/code/study/element-finder/src/entry/panel.js":"6","/Users/tangxiaobao/Documents/code/study/element-finder/src/entry/index.js":"7"},{"size":2067,"mtime":1606374278892,"results":"8","hashOfConfig":"9"},{"size":12445,"mtime":1606304244961,"results":"10","hashOfConfig":"9"},{"size":378,"mtime":1606318266693,"results":"11","hashOfConfig":"9"},{"size":1790,"mtime":1606455088268,"results":"12","hashOfConfig":"9"},{"size":91,"mtime":1606455088268,"results":"13","hashOfConfig":"9"},{"size":215,"mtime":1606455605162,"results":"14","hashOfConfig":"9"},{"size":197,"mtime":1606455632524,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"18"},"ilwxt1",{"filePath":"19","messages":"20","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/tangxiaobao/Documents/code/study/element-finder/src/common/index.js",["33"],"/* globals chrome */\nlet tabs = {};\nconst inspectFile = \"static/js/content.js\";\nconst activeIcon = \"active-64.png\";\nconst defaultIcon = \"default-64.png\";\n\nconst inspect = {\n  toggleActivate: (id, type, icon) => {\n    chrome.tabs.executeScript(id, { file: inspectFile }, () => {\n      chrome.tabs.sendMessage(id, { action: type });\n    });\n    chrome.browserAction.setIcon({\n      tabId: id,\n      path: { 19: \"icons/\" + icon },\n    });\n  },\n};\n\nfunction isSupportedProtocolAndFileType(urlString) {\n  if (!urlString) {\n    return false;\n  }\n  const supportedProtocols = [\"https:\", \"http:\", \"file:\"];\n  const notSupportedFiles = [\"xml\", \"pdf\", \"rss\"];\n  const extension = urlString.split(\".\").pop().split(/\\#|\\?/)[0];\n  const url = document.createElement(\"a\");\n  url.href = urlString;\n  return (\n    supportedProtocols.indexOf(url.protocol) !== -1 &&\n    notSupportedFiles.indexOf(extension) === -1\n  );\n}\n\nfunction toggle(tab) {\n  if (isSupportedProtocolAndFileType(tab.url)) {\n    if (!tabs[tab.id]) {\n      tabs[tab.id] = Object.create(inspect);\n      inspect.toggleActivate(tab.id, \"activate\", activeIcon);\n    } else {\n      inspect.toggleActivate(tab.id, \"deactivate\", defaultIcon);\n      for (const tabId in tabs) {\n        if (tabId === tab.id) delete tabs[tabId];\n      }\n    }\n  }\n}\n\nfunction close(tab) {\n  if (isSupportedProtocolAndFileType(tab.url)) {\n    inspect.toggleActivate(tab.id, \"deactivate\", defaultIcon);\n    tabs = {};\n    if (tabs[tab.id]) {\n      for (const tabId in tabs) {\n        if (tabId === tab.id) delete tabs[tabId];\n      }\n    } else {\n    }\n  }\n}\n\nfunction deactivateItem(tab) {\n  if (tab) {\n    if (isSupportedProtocolAndFileType(tab.url)) {\n      for (const tabId in tabs) {\n        if (tabId === tab.id) {\n          delete tabs[tabId];\n        }\n        inspect.toggleActivate(tab.id, \"deactivate\", defaultIcon);\n      }\n    }\n  }\n}\n\nfunction getActiveTab() {\n  chrome.tabs.query({ active: true, currentWindow: true }, (tab) => {\n    deactivateItem(tab);\n  });\n}\n\nexport { getActiveTab, deactivateItem, toggle, close, inspect };\n","/Users/tangxiaobao/Documents/code/study/element-finder/src/content/index.js",["34"],"/* globals chrome */\nvar xPathFinder =\n  xPathFinder ||\n  (() => {\n    class Inspector {\n      constructor() {\n        this.win = window;\n        this.doc = window.document;\n\n        this.draw = this.draw.bind(this);\n        this.getData = this.getData.bind(this);\n        this.setOptions = this.setOptions.bind(this);\n\n        this.cssNode = \"xpath-css\";\n        this.contentNode = \"xpath-content\";\n        this.overlayElement = \"xpath-overlay\";\n      }\n\n      getData(e, iframe) {\n        e.stopImmediatePropagation();\n        e.preventDefault && e.preventDefault();\n        e.stopPropagation && e.stopPropagation();\n\n        if (e.target.id !== this.contentNode) {\n          this.XPath = this.getXPath(e.target);\n          const contentNode = document.getElementById(this.contentNode);\n          const iframeNode = window.frameElement || iframe;\n          const contentString = iframeNode\n            ? `Iframe: ${this.getXPath(iframeNode)}<br/>XPath: ${this.XPath}`\n            : this.XPath;\n\n          if (contentNode) {\n            contentNode.innerHTML = contentString;\n          } else {\n            const contentHtml = document.createElement(\"div\");\n            contentHtml.innerHTML = contentString;\n            contentHtml.id = this.contentNode;\n            document.body.appendChild(contentHtml);\n          }\n          this.options.clipboard && this.copyText(this.XPath);\n        }\n      }\n\n      getOptions() {\n        const storage = chrome.storage && chrome.storage.local;\n        const promise = storage.get(\n          {\n            inspector: true,\n            clipboard: true,\n            shortid: true,\n            position: \"bl\",\n          },\n          this.setOptions\n        );\n        promise && promise.then && promise.then(this.setOptions());\n      }\n\n      setOptions(options) {\n        this.options = options;\n        let position = \"bottom:0;left:0\";\n        switch (options.position) {\n          case \"tl\":\n            position = \"top:0;left:0\";\n            break;\n          case \"tr\":\n            position = \"top:0;right:0\";\n            break;\n          case \"br\":\n            position = \"bottom:0;right:0\";\n            break;\n          default:\n            break;\n        }\n        this.styles = `body *{cursor:crosshair!important;}#xpath-content{${position};cursor:initial!important;padding:10px;background:gray;color:white;position:fixed;font-size:14px;z-index:10000001;}`;\n        this.activate();\n      }\n\n      createOverlayElements() {\n        const overlayStyles = {\n          background: \"rgba(120, 170, 210, 0.7)\",\n          padding: \"rgba(77, 200, 0, 0.3)\",\n          margin: \"rgba(255, 155, 0, 0.3)\",\n          border: \"rgba(255, 200, 50, 0.3)\",\n        };\n\n        this.container = this.doc.createElement(\"div\");\n        this.node = this.doc.createElement(\"div\");\n        this.border = this.doc.createElement(\"div\");\n        this.padding = this.doc.createElement(\"div\");\n        this.content = this.doc.createElement(\"div\");\n\n        this.border.style.borderColor = overlayStyles.border;\n        this.padding.style.borderColor = overlayStyles.padding;\n        this.content.style.backgroundColor = overlayStyles.background;\n\n        Object.assign(this.node.style, {\n          borderColor: overlayStyles.margin,\n          pointerEvents: \"none\",\n          position: \"fixed\",\n        });\n\n        this.container.id = this.overlayElement;\n        this.container.style.zIndex = 10000000;\n        this.node.style.zIndex = 10000000;\n\n        this.container.appendChild(this.node);\n        this.node.appendChild(this.border);\n        this.border.appendChild(this.padding);\n        this.padding.appendChild(this.content);\n      }\n\n      removeOverlay() {\n        const overlayHtml = document.getElementById(this.overlayElement);\n        overlayHtml && overlayHtml.remove();\n      }\n\n      copyText(XPath) {\n        const hdInp = document.createElement(\"textarea\");\n        hdInp.textContent = XPath;\n        document.body.appendChild(hdInp);\n        hdInp.select();\n        document.execCommand(\"copy\");\n        hdInp.remove();\n      }\n\n      draw(e) {\n        const node = e.target;\n        if (node.id !== this.contentNode) {\n          this.removeOverlay();\n\n          const box = this.getNestedBoundingClientRect(node, this.win);\n          const dimensions = this.getElementDimensions(node);\n\n          this.boxWrap(dimensions, \"margin\", this.node);\n          this.boxWrap(dimensions, \"border\", this.border);\n          this.boxWrap(dimensions, \"padding\", this.padding);\n\n          Object.assign(this.content.style, {\n            height:\n              box.height -\n              dimensions.borderTop -\n              dimensions.borderBottom -\n              dimensions.paddingTop -\n              dimensions.paddingBottom +\n              \"px\",\n            width:\n              box.width -\n              dimensions.borderLeft -\n              dimensions.borderRight -\n              dimensions.paddingLeft -\n              dimensions.paddingRight +\n              \"px\",\n          });\n\n          Object.assign(this.node.style, {\n            top: box.top - dimensions.marginTop + \"px\",\n            left: box.left - dimensions.marginLeft + \"px\",\n          });\n\n          this.doc.body.appendChild(this.container);\n        }\n      }\n\n      activate() {\n        this.createOverlayElements();\n        // add styles\n        if (!document.getElementById(this.cssNode)) {\n          const styles = document.createElement(\"style\");\n          styles.innerText = this.styles;\n          styles.id = this.cssNode;\n          document.getElementsByTagName(\"head\")[0].appendChild(styles);\n        }\n        // add listeners for all frames and root\n        document.addEventListener(\"click\", this.getData, true);\n        this.options.inspector &&\n          document.addEventListener(\"mouseover\", this.draw);\n        const frameLength = window.parent.frames.length;\n        for (let i = 0; i < frameLength; i++) {\n          let frame = window.parent.frames[i];\n          frame.document.addEventListener(\n            \"click\",\n            (e) => this.getData(e, frame.frameElement),\n            true\n          );\n          this.options.inspector &&\n            frame.document.addEventListener(\"mouseover\", this.draw);\n        }\n      }\n\n      deactivate() {\n        // remove styles\n        const cssNode = document.getElementById(this.cssNode);\n        cssNode && cssNode.remove();\n        // remove overlay\n        this.removeOverlay();\n        // remove xpath html\n        const contentNode = document.getElementById(this.contentNode);\n        contentNode && contentNode.remove();\n        // remove listeners for all frames and root\n        document.removeEventListener(\"click\", this.getData, true);\n        this.options &&\n          this.options.inspector &&\n          document.removeEventListener(\"mouseover\", this.draw);\n        const frameLength = window.parent.frames.length;\n        for (let i = 0; i < frameLength; i++) {\n          let frameDocument = window.parent.frames[i].document;\n          frameDocument.removeEventListener(\"click\", this.getData, true);\n          this.options &&\n            this.options.inspector &&\n            frameDocument.removeEventListener(\"mouseover\", this.draw);\n        }\n      }\n\n      getXPath(el) {\n        let nodeElem = el;\n        if (nodeElem.id && this.options.shortid) {\n          return `//*[@id=\"${nodeElem.id}\"]`;\n        }\n        const parts = [];\n        while (nodeElem && nodeElem.nodeType === Node.ELEMENT_NODE) {\n          let nbOfPreviousSiblings = 0;\n          let hasNextSiblings = false;\n          let sibling = nodeElem.previousSibling;\n          while (sibling) {\n            if (\n              sibling.nodeType !== Node.DOCUMENT_TYPE_NODE &&\n              sibling.nodeName === nodeElem.nodeName\n            ) {\n              nbOfPreviousSiblings++;\n            }\n            sibling = sibling.previousSibling;\n          }\n          sibling = nodeElem.nextSibling;\n          while (sibling) {\n            if (sibling.nodeName === nodeElem.nodeName) {\n              hasNextSiblings = true;\n              break;\n            }\n            sibling = sibling.nextSibling;\n          }\n          const prefix = nodeElem.prefix ? nodeElem.prefix + \":\" : \"\";\n          const nth =\n            nbOfPreviousSiblings || hasNextSiblings\n              ? `[${nbOfPreviousSiblings + 1}]`\n              : \"\";\n          parts.push(prefix + nodeElem.localName + nth);\n          nodeElem = nodeElem.parentNode;\n        }\n        return parts.length ? \"/\" + parts.reverse().join(\"/\") : \"\";\n      }\n\n      getElementDimensions(domElement) {\n        const calculatedStyle = window.getComputedStyle(domElement);\n        return {\n          borderLeft: +calculatedStyle.borderLeftWidth.match(/[0-9]*/)[0],\n          borderRight: +calculatedStyle.borderRightWidth.match(/[0-9]*/)[0],\n          borderTop: +calculatedStyle.borderTopWidth.match(/[0-9]*/)[0],\n          borderBottom: +calculatedStyle.borderBottomWidth.match(/[0-9]*/)[0],\n          marginLeft: +calculatedStyle.marginLeft.match(/[0-9]*/)[0],\n          marginRight: +calculatedStyle.marginRight.match(/[0-9]*/)[0],\n          marginTop: +calculatedStyle.marginTop.match(/[0-9]*/)[0],\n          marginBottom: +calculatedStyle.marginBottom.match(/[0-9]*/)[0],\n          paddingLeft: +calculatedStyle.paddingLeft.match(/[0-9]*/)[0],\n          paddingRight: +calculatedStyle.paddingRight.match(/[0-9]*/)[0],\n          paddingTop: +calculatedStyle.paddingTop.match(/[0-9]*/)[0],\n          paddingBottom: +calculatedStyle.paddingBottom.match(/[0-9]*/)[0],\n        };\n      }\n\n      getOwnerWindow(node) {\n        if (!node.ownerDocument) {\n          return null;\n        }\n        return node.ownerDocument.defaultView;\n      }\n\n      getOwnerIframe(node) {\n        const nodeWindow = this.getOwnerWindow(node);\n        if (nodeWindow) {\n          return nodeWindow.frameElement;\n        }\n        return null;\n      }\n\n      getBoundingClientRectWithBorderOffset(node) {\n        const dimensions = this.getElementDimensions(node);\n        return this.mergeRectOffsets([\n          node.getBoundingClientRect(),\n          {\n            top: dimensions.borderTop,\n            left: dimensions.borderLeft,\n            bottom: dimensions.borderBottom,\n            right: dimensions.borderRight,\n            width: 0,\n            height: 0,\n          },\n        ]);\n      }\n\n      mergeRectOffsets(rects) {\n        return rects.reduce((previousRect, rect) => {\n          if (previousRect === null) {\n            return rect;\n          }\n          return {\n            top: previousRect.top + rect.top,\n            left: previousRect.left + rect.left,\n            width: previousRect.width,\n            height: previousRect.height,\n            bottom: previousRect.bottom + rect.bottom,\n            right: previousRect.right + rect.right,\n          };\n        });\n      }\n\n      getNestedBoundingClientRect(node, boundaryWindow) {\n        const ownerIframe = this.getOwnerIframe(node);\n        if (ownerIframe && ownerIframe !== boundaryWindow) {\n          const rects = [node.getBoundingClientRect()];\n          let currentIframe = ownerIframe;\n          let onlyOneMore = false;\n          while (currentIframe) {\n            const rect = this.getBoundingClientRectWithBorderOffset(\n              currentIframe\n            );\n            rects.push(rect);\n            currentIframe = this.getOwnerIframe(currentIframe);\n            if (onlyOneMore) {\n              break;\n            }\n            if (\n              currentIframe &&\n              this.getOwnerWindow(currentIframe) === boundaryWindow\n            ) {\n              onlyOneMore = true;\n            }\n          }\n          return this.mergeRectOffsets(rects);\n        }\n        return node.getBoundingClientRect();\n      }\n\n      boxWrap(dimensions, parameter, node) {\n        Object.assign(node.style, {\n          borderTopWidth: dimensions[parameter + \"Top\"] + \"px\",\n          borderLeftWidth: dimensions[parameter + \"Left\"] + \"px\",\n          borderRightWidth: dimensions[parameter + \"Right\"] + \"px\",\n          borderBottomWidth: dimensions[parameter + \"Bottom\"] + \"px\",\n          borderStyle: \"solid\",\n        });\n      }\n    }\n\n    const inspect = new Inspector();\n\n    chrome.runtime.onMessage.addListener((request) => {\n      if (request.action === \"activate\") {\n        return inspect.getOptions();\n      }\n      return inspect.deactivate();\n    });\n\n    return true;\n  })();\n","/Users/tangxiaobao/Documents/code/study/element-finder/src/background/index.js",["35"],"/* globals chrome */\nimport { toggle, getActiveTab } from \"@/common\";\n\nchrome.commands.onCommand.addListener((command) => {\n  if (command === \"toggle-xpath\") {\n    chrome.tabs.query({ active: true, currentWindow: true }, (tab) => {\n      toggle(tab[0]);\n    });\n  }\n});\n\n// chrome.tabs.onUpdated.addListener(getActiveTab);\n// chrome.browserAction.onClicked.addListener(toggle);\n","/Users/tangxiaobao/Documents/code/study/element-finder/src/pages/popup/index.js",[],"/Users/tangxiaobao/Documents/code/study/element-finder/src/pages/panel/index.js",[],"/Users/tangxiaobao/Documents/code/study/element-finder/src/entry/panel.js",[],"/Users/tangxiaobao/Documents/code/study/element-finder/src/entry/index.js",[],{"ruleId":"36","severity":1,"message":"37","line":25,"column":55,"nodeType":"38","messageId":"39","endLine":25,"endColumn":56,"suggestions":"40"},{"ruleId":"41","severity":1,"message":"42","line":3,"column":3,"nodeType":"43","messageId":"44","endLine":3,"endColumn":14},{"ruleId":"45","severity":1,"message":"46","line":2,"column":18,"nodeType":"43","messageId":"47","endLine":2,"endColumn":30},"no-useless-escape","Unnecessary escape character: \\#.","Literal","unnecessaryEscape",["48","49"],"no-use-before-define","'xPathFinder' was used before it was defined.","Identifier","usedBeforeDefined","no-unused-vars","'getActiveTab' is defined but never used.","unusedVar",{"messageId":"50","fix":"51","desc":"52"},{"messageId":"53","fix":"54","desc":"55"},"removeEscape",{"range":"56","text":"57"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"58","text":"59"},"Replace the `\\` with `\\\\` to include the actual backslash character.",[704,705],"",[704,704],"\\"]